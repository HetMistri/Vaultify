plugins {
    id 'java'
    id 'application'
}

group = 'com.vaultify'
version = '1.0.0'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.postgresql:postgresql:42.7.4'
    implementation 'com.google.code.gson:gson:2.10.1'
}

sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
        resources {
            srcDirs = ['resources']
        }
    }
}

application {
    mainClass = 'com.vaultify.app.VaultifyApplication'
}

// Configure the default 'run' task to accept stdin
run {
    standardInput = System.in
}

jar {
    // Ensure duplicate classes/resources don't break packaging
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Jar manifest (for java -jar)
    manifest {
        attributes(
                'Main-Class': 'com.vaultify.app.VaultifyApplication'
        )
    }

    // Build fat jar (includes all runtime dependencies)
    from {
        configurations.runtimeClasspath.collect { file ->
            file.isDirectory() ? file : zipTree(file)
        }
    }
}


tasks.register('runLocal', JavaExec) {
    group = "vaultify"
    description = "Run Vaultify locally without Docker"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'com.vaultify.app.VaultifyApplication'
    standardInput = System.in
    // Start ledger-server automatically unless skipLedger=true
    doFirst {
        if (System.properties['skipLedger'] == 'true') {
            println "[runLocal] Skipping ledger server startup (skipLedger=true)"
        } else {
            if (!project.ext.has('ledgerProcess') || !(project.ext.ledgerProcess?.isAlive())) {
                // Additional port check to prevent duplicate start on new Gradle invocation
                def portInUse = false
                try {
                    new Socket('127.0.0.1', 3000).withCloseable { portInUse = true }
                } catch(Exception ignored) {}
                if (portInUse) {
                    println "[runLocal] Ledger server already running on port 3000"
                } else {
                    println "[runLocal] Launching ledger server (inline)"
                    def isWindows = System.getProperty('os.name').toLowerCase().contains('win')
                    def cmd = isWindows ? ['cmd','/c','npm','run','dev'] : ['npm','run','dev']
                    def workingDir = new File("${projectDir}/ledger-server")
                    if (!workingDir.exists()) {
                        println "[runLocal] WARNING: ledger-server directory not found at ${workingDir}"
                    } else {
                        Process p = new ProcessBuilder(cmd)
                                .directory(workingDir)
                                .redirectErrorStream(true)
                                .start()
                        project.ext.ledgerProcess = p
                        Thread.start {
                            p.inputStream.withReader { r -> r.eachLine { line -> println "[ledger] $line" } }
                        }
                        println "[runLocal] Ledger server started (PID=${p.pid()})"
                    }
                }
            } else {
                println "[runLocal] Ledger server already running"
            }
        }
    }
}

// Launch the Node.js ledger server in background (non-blocking)
tasks.register('runLedgerService') {
    group = 'vaultify'
    description = 'Start the external ledger-server (npm run dev) in background'
    doLast {
        if (project.ext.has('ledgerProcess') && project.ext.ledgerProcess?.isAlive()) {
            println "[runLedgerService] Ledger server already running"
            return
        }
        // Port check so we don't spawn duplicate failing process
        def portInUse = false
        try { new Socket('127.0.0.1',3000).withCloseable { portInUse = true } } catch(Exception ignored) {}
        if (portInUse) {
            println "[runLedgerService] Detected existing server on port 3000; skipping spawn"
            return
        }
        def isWindows = System.getProperty('os.name').toLowerCase().contains('win')
        def cmd = isWindows ? ['cmd','/c','npm','run','dev'] : ['npm','run','dev']
        def workingDir = new File("${projectDir}/ledger-server")
        if (!workingDir.exists()) {
            throw new GradleException("ledger-server directory not found at ${workingDir}")
        }
        println "[runLedgerService] Starting ledger server in ${workingDir}"
        Process p = new ProcessBuilder(cmd)
                .directory(workingDir)
                .redirectErrorStream(true)
                .start()
        project.ext.ledgerProcess = p
        Thread.start {
            p.inputStream.withReader { r -> r.eachLine { line -> println "[ledger] $line" } }
        }
        println "[runLedgerService] Ledger server started (PID=${p.pid()})"
    }
}

// Stop the background ledger server if running
tasks.register('stopLedgerService') {
    group = 'vaultify'
    description = 'Stop the background ledger-server process'
    doLast {
        if (project.ext.has('ledgerProcess') && project.ext.ledgerProcess?.isAlive()) {
            println "[stopLedgerService] Stopping ledger server (PID=${project.ext.ledgerProcess.pid()})"
            project.ext.ledgerProcess.destroy()
            project.ext.ledgerProcess = null
        } else {
            println "[stopLedgerService] No running ledger server process found"
        }
    }
}

tasks.register('testDb', JavaExec) {
    group = "vaultify"
    description = "Test database connection"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'com.vaultify.db.Database'
}

tasks.register('testAuth', JavaExec) {
    group = "vaultify"
    description = "Test authentication (login/signup)"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'com.vaultify.test.AuthTest'
}

tasks.register('rebuild') {
    group = "vaultify"
    description = "Clean and build the entire project"
    dependsOn 'clean', 'build'
}

tasks.register('dockerBuild') {
    group = "vaultify"
    description = "Build Docker images after building jar"
    dependsOn 'build'
    doLast {
        exec {
            commandLine 'docker', 'compose', 'build'
        }
    }
}
